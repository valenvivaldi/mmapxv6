diff -rupN xv6-unrc/defs.h xv6-nuevo/defs.h
--- xv6-unrc/defs.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/defs.h	2018-05-09 19:26:11.141106456 -0300
@@ -8,6 +8,7 @@ struct rtcdate;
 struct spinlock;
 struct stat;
 struct superblock;
+struct semaphore;
 
 // bio.c
 void            binit(void);
@@ -118,6 +119,16 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            calculateaging(void);
+
+// semaphore.c
+int             semget(int,int);
+void            seminit(void);
+int             semfree(int);
+int             semup(int);
+int             semdown(int);
+void            semclose(struct semaphore*);
+struct semaphore* semdup(struct semaphore*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff -rupN xv6-unrc/exec.c xv6-nuevo/exec.c
--- xv6-unrc/exec.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/exec.c	2018-05-23 19:40:28.013687481 -0300
@@ -53,12 +53,16 @@ exec(char *path, char **argv)
   end_op();
   ip = 0;
 
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
-  sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  sz = PGROUNDUP(sz+PGSIZE);
+
+  // Save the top of the stack pages.
+  proc->sstack=sz;
+
+  // Skip MAXSTACKPAGES-1 pages and allocate one.
+  sz = PGROUNDUP(sz+(PGSIZE*(MAXSTACKPAGES-1)));
+  if((sz = allocuvm(pgdir, sz, sz + PGSIZE)) == 0)
     goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  //clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
   sp = sz;
 
   // Push argument strings, prepare rest of stack in ustack.
diff -rupN xv6-unrc/main.c xv6-nuevo/main.c
--- xv6-unrc/main.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/main.c	2018-05-09 18:57:19.241141797 -0300
@@ -31,6 +31,7 @@ main(void)
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
+  seminit();       // semaphore table
   iinit();         // inode cache
   ideinit();       // disk
   if(!ismp)
@@ -46,7 +47,7 @@ main(void)
 static void
 mpenter(void)
 {
-  switchkvm(); 
+  switchkvm();
   seginit();
   lapicinit();
   mpmain();
@@ -83,7 +84,7 @@ startothers(void)
     if(c == cpus+cpunum())  // We've started already.
       continue;
 
-    // Tell entryother.S what stack to use, where to enter, and what 
+    // Tell entryother.S what stack to use, where to enter, and what
     // pgdir to use. We cannot use kpgdir yet, because the AP processor
     // is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
@@ -101,7 +102,7 @@ startothers(void)
 
 // Boot page table used in entry.S and entryother.S.
 // Page directories (and page tables), must start on a page boundary,
-// hence the "__aligned__" attribute.  
+// hence the "__aligned__" attribute.
 // Use PTE_PS in page directory entry to enable 4Mbyte pages.
 __attribute__((__aligned__(PGSIZE)))
 pde_t entrypgdir[NPDENTRIES] = {
diff -rupN xv6-unrc/Makefile xv6-nuevo/Makefile
--- xv6-unrc/Makefile	2015-04-08 16:00:19.000000000 -0300
+++ xv6-nuevo/Makefile	2018-05-23 14:01:34.285368346 -0300
@@ -15,6 +15,7 @@ OBJS = \
 	picirq.o\
 	pipe.o\
 	proc.o\
+	semaphore.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
@@ -32,7 +33,7 @@ OBJS = \
 # TOOLPREFIX = i386-jos-elf
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -147,6 +148,12 @@ _forktest: user/forktest.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest user/forktest.o user/ulib.o user/usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
+_semaphoretest: user/semaphoretest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _semaphoretest user/semaphoretest.o user/ulib.o user/usys.o
+	$(OBJDUMP) -S _semaphoretest > semaphoretest.asm
+
 mkfs: mkfs.c fs.h
 	gcc -Werror -Wall -o mkfs mkfs.c
 
@@ -157,6 +164,7 @@ mkfs: mkfs.c fs.h
 .PRECIOUS: %.o
 
 UPROGS=\
+	_agingtest\
 	_cat\
 	_echo\
 	_forktest\
@@ -166,7 +174,10 @@ UPROGS=\
 	_ln\
 	_ls\
 	_mkdir\
+	_pagestest\
+	_prioritytest\
 	_rm\
+	_semaphoretest\
 	_sh\
 	_stressfs\
 	_usertests\
@@ -178,7 +189,7 @@ fs.img: mkfs README $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o user/*.o *.d user/*.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
@@ -239,7 +250,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c user/ulib.c user/user.h user/cat.c user/echo.c user/forktest.c user/grep.c user/kill.c\
+	mkfs.c user/ulib.c user/user.h user/cat.c user/echo.c user/forktest.c user/semaphoretest.c user/grep.c user/kill.c\
 	user/ln.c user/ls.c user/mkdir.c user/rm.c user/stressfs.c user/usertests.c user/wc.c user/zombie.c\
 	user/printf.c user/umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff -rupN xv6-unrc/mkfs.c xv6-nuevo/mkfs.c
--- xv6-unrc/mkfs.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/mkfs.c	2018-03-22 10:11:08.791640000 -0300
@@ -11,7 +11,7 @@
 #include "stat.h"
 #include "param.h"
 
-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+//#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0) redefine la biblioteca estandar por eso hay que comentarlo
 
 int nblocks = (995-LOGSIZE);
 int nlog = LOGSIZE;
diff -rupN xv6-unrc/param.h xv6-nuevo/param.h
--- xv6-unrc/param.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/param.h	2018-05-23 19:39:02.810947254 -0300
@@ -10,4 +10,11 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-
+#define QUANTUM      5  // maximum number of ticks per process
+#define MLFLEVELS    4  // number of levels in the MLF structure
+#define TICKSFORAGE  10  // amount of ticks to increase the age of the process
+#define AGEFORAGINGS 5  // age that the processes must reach to update the priority.
+#define MLFMAXPRIORITY  0  // level with the highest priority in the MLF structure.
+#define MAXSEM 64  // maximum number of semaphores in the system.
+#define MAXPROCSEM 5  // maximum number of semaphores per process.
+#define MAXSTACKPAGES 8  // maximum number of stack pages per process.
diff -rupN xv6-unrc/proc.c xv6-nuevo/proc.c
--- xv6-unrc/proc.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/proc.c	2018-05-22 19:07:17.010758683 -0300
@@ -4,14 +4,91 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "x86.h"
+#include "semaphore.h"
 #include "proc.h"
 #include "spinlock.h"
 
+struct mlf{  // structure that represents MLF
+  struct proc *first;
+  struct proc *last;
+};
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
+  struct mlf mlf[MLFLEVELS];  // added the MLF structure to the ptable
 } ptable;
 
+//enqueue the process in the corresponding priority
+static void
+make_runnable(struct proc* p)
+{
+  if(ptable.mlf[p->priority].last==0){
+    ptable.mlf[p->priority].first = p;
+  } else{
+    ptable.mlf[p->priority].last->next = p;
+  }
+  ptable.mlf[p->priority].last=p;
+  p->next=0;
+  p->age=0;
+  p->state=RUNNABLE;
+}
+
+//dequeue first element of the level "level"
+static struct proc*
+unqueue(int level)
+{
+  struct proc* p=ptable.mlf[level].first;
+
+  if(!ptable.mlf[level].first)
+    panic("empty level");
+  if(ptable.mlf[level].first==ptable.mlf[level].last){
+    ptable.mlf[level].last = ptable.mlf[level].first = 0;
+  }else{
+    ptable.mlf[level].first=p->next;
+  }
+  if(p->state!=RUNNABLE)
+    panic("unqueue not RUNNABLE process");
+  return p;
+}
+
+//unqueue the process, it increases the priority if it corresponds, and queues it in the new level.
+static void
+levelupdate(struct proc* p)
+{
+  unqueue(p->priority);
+  if(p->priority>MLFMAXPRIORITY)
+    p->priority--;
+  make_runnable(p);
+}
+
+//go through MLF, looking for processes that reach AGEFORAGINGS and raise the priority.
+//call procdump to show them.
+void
+calculateaging(void)
+{
+  struct proc* p;
+  int l;
+  acquire(&ptable.lock);
+  for(l=MLFMAXPRIORITY; l<MLFLEVELS; l++){
+    p=ptable.mlf[l].first;
+    if (p){
+      p->age++;  // increase the age to the process
+      //procdump();
+      if(p->age == AGEFORAGINGS){
+        if(ptable.mlf[p->priority].first!=p)
+          panic("it does not eliminate the first element of the level.");
+        procdump();
+        cprintf("/**************************************************************/\n");
+        levelupdate(p);  // call to levelupdate
+        procdump();
+        cprintf("/--------------------------------------------------------------/\n");
+      }
+    }
+  }
+  release(&ptable.lock);
+}
+
 static struct proc *initproc;
 
 int nextpid = 1;
@@ -55,11 +132,11 @@ found:
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
-  
+
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
-  
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -70,6 +147,8 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  p->priority=0;  // initializes the priority.
+  p->age=0;  // initialize age.
   return p;
 }
 
@@ -80,7 +159,7 @@ userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
-  
+
   p = allocproc();
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
@@ -99,7 +178,8 @@ userinit(void)
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  p->state = RUNNABLE;
+
+  make_runnable(p);
 }
 
 // Grow current process's memory by n bytes.
@@ -108,7 +188,7 @@ int
 growproc(int n)
 {
   uint sz;
-  
+
   sz = proc->sz;
   if(n > 0){
     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
@@ -143,6 +223,8 @@ fork(void)
     return -1;
   }
   np->sz = proc->sz;
+  np->sstack = proc->sstack;
+
   np->parent = proc;
   *np->tf = *proc->tf;
 
@@ -152,17 +234,23 @@ fork(void)
   for(i = 0; i < NOFILE; i++)
     if(proc->ofile[i])
       np->ofile[i] = filedup(proc->ofile[i]);
+
+  //duplicate semaphore a new process
+  for(i = 0; i < MAXPROCSEM; i++)
+    if(proc->osemaphore[i])
+      np->osemaphore[i] = semdup(proc->osemaphore[i]);
+
   np->cwd = idup(proc->cwd);
 
   safestrcpy(np->name, proc->name, sizeof(proc->name));
- 
+
   pid = np->pid;
 
   // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
-  np->state = RUNNABLE;
+  make_runnable(np);
   release(&ptable.lock);
-  
+
   return pid;
 }
 
@@ -173,7 +261,7 @@ void
 exit(void)
 {
   struct proc *p;
-  int fd;
+  int fd,idsem;
 
   if(proc == initproc)
     panic("init exiting");
@@ -186,6 +274,14 @@ exit(void)
     }
   }
 
+  // Close all open semaphore.
+  for(idsem = 0; idsem < MAXPROCSEM; idsem++){
+    if(proc->osemaphore[idsem]){
+      semclose(proc->osemaphore[idsem]);
+      proc->osemaphore[idsem] = 0;
+    }
+  }
+
   begin_op();
   iput(proc->cwd);
   end_op();
@@ -266,21 +362,26 @@ void
 scheduler(void)
 {
   struct proc *p;
-
+  int l;
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
-    // Loop over process table looking for process to run.
+    // Loop over MLF looking for process to execute according to priority levels.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for(l=MLFMAXPRIORITY; l<MLFLEVELS; l++){
+      if (!ptable.mlf[l].first)
         continue;
+      p=unqueue(l);
+
+
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       proc = p;
+
+
       switchuvm(p);
       p->state = RUNNING;
       swtch(&cpu->scheduler, proc->context);
@@ -289,9 +390,9 @@ scheduler(void)
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       proc = 0;
+      break;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -320,7 +421,9 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
-  proc->state = RUNNABLE;
+  if(proc->priority<MLFLEVELS-1)
+    proc->priority++;
+  make_runnable(proc);
   sched();
   release(&ptable.lock);
 }
@@ -336,12 +439,12 @@ forkret(void)
 
   if (first) {
     // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot 
+    // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
     first = 0;
     initlog();
   }
-  
+
   // Return to "caller", actually trapret (see allocproc).
 }
 
@@ -385,14 +488,18 @@ sleep(void *chan, struct spinlock *lk)
 //PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
+// If applicable, the priority of the process increases.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    if(p->state == SLEEPING && p->chan == chan){
+      if (p->priority>0)
+        p->priority--;
+      make_runnable(p);
+    }
 }
 
 // Wake up all processes sleeping on chan.
@@ -418,7 +525,7 @@ kill(int pid)
       p->killed = 1;
       // Wake process from sleep if necessary.
       if(p->state == SLEEPING)
-        p->state = RUNNABLE;
+        make_runnable(p);
       release(&ptable.lock);
       return 0;
     }
@@ -446,7 +553,7 @@ procdump(void)
   struct proc *p;
   char *state;
   uint pc[10];
-  
+
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == UNUSED)
       continue;
@@ -454,7 +561,7 @@ procdump(void)
       state = states[p->state];
     else
       state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
+    cprintf("%d %s %s priority:%d age:%d", p->pid, state, p->name,p->priority,p->age);
     if(p->state == SLEEPING){
       getcallerpcs((uint*)p->context->ebp+2, pc);
       for(i=0; i<10 && pc[i] != 0; i++)
diff -rupN xv6-unrc/proc.h xv6-nuevo/proc.h
--- xv6-unrc/proc.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/proc.h	2018-05-23 19:48:51.970586888 -0300
@@ -10,7 +10,7 @@ struct cpu {
   volatile uint started;       // Has the CPU started?
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
-  
+
   // Cpu-local storage variables; see below
   struct cpu *cpu;
   struct proc *proc;           // The currently-running process.
@@ -66,6 +66,12 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  ushort ticks;                // Number of ticks
+  ushort priority;
+  struct proc* next;
+  ushort age;
+  struct semaphore *osemaphore[MAXPROCSEM]; // Open semaphore
+  uint sstack;    //  keeps the top of the last page of the stack (may be unassigned).
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -rupN xv6-unrc/semaphore.c xv6-nuevo/semaphore.c
--- xv6-unrc/semaphore.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/semaphore.c	2018-05-15 11:08:06.239006243 -0300
@@ -0,0 +1,221 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "semaphore.h"
+
+// Structure that contains all the semaphore of the system and LOCK to guarantee uniqueness.
+struct {
+  struct spinlock lock;
+  struct semaphore sem[MAXSEM];
+} stable;
+
+// Initializes the LOCK of the semaphore table.
+void
+seminit(void)
+{
+  initlock(&stable.lock, "stable");
+}
+
+// Assigns a place in the open semaphore array of the process and returns the position.
+static int
+allocinprocess()
+{
+  int i;
+  struct semaphore* s;
+
+  for(i = 0; i < MAXPROCSEM; i++){
+    s=proc->osemaphore[i];
+    if(!s)
+      return i;
+  }
+  return -1;
+}
+
+// Find the id passed as an argument between the ids of the open semaphores of the process and return its position.
+static int
+searchinprocess(int id)
+{
+  struct semaphore* s;
+  int i;
+
+  for(i = 0; i < MAXPROCSEM; i++){
+    s=proc->osemaphore[i];
+    if(s && s->id==id){
+        return i;
+    }
+  }
+  return -1;
+}
+
+// Assign a place in the semaphore table of the system and return a pointer to it.
+// if the table is full, return null (0)
+static struct semaphore*
+allocinsystem()
+{
+  struct semaphore* s;
+  int i;
+  for(i=0; i < MAXSEM; i++){
+    s=&stable.sem[i];
+    if(s->references==0)
+      return s;
+  }
+  return 0;
+}
+
+// If semid is -1 it creates a new traffic light and returns its id.
+// if semid is greater than or equal to 0, find the semaphore in the system,
+// adds references to it and returns its id.
+// if there is no place in the semaphore table of the process, return -2.
+// if there is no place in the system's semaphore table, return -3.
+// if semid> 0 and the semaphore is not in use, return -1.
+// if semid <-1 or semid> MAXSEM, return -4.
+int
+semget(int semid, int initvalue)
+{
+  int position=0,retvalue;
+  struct semaphore* s;
+
+  if(semid<-1 || semid>=MAXSEM)
+    return -4;
+  acquire(&stable.lock);
+  position=allocinprocess();
+  if(position==-1){
+    retvalue=-2;
+    goto retget;
+  }
+  if(semid==-1){
+    s=allocinsystem();
+    if(!s){
+      retvalue=-3;
+      goto retget;
+    }
+    s->id=s-stable.sem;
+    s->value=initvalue;
+    retvalue=s->id;
+    goto found;
+  }
+  if(semid>=0){
+    for(s = stable.sem; s < stable.sem + MAXSEM; s++){
+      if(s->id==semid && ((s->references)>0)){
+        retvalue=s->id;
+        goto found;
+      }
+      if(s->id==semid && ((s->references)==0)){
+        retvalue=-1;
+        goto retget;
+      }
+    }
+    retvalue=-5;
+    goto retget;
+  }
+found:
+  s->references++;
+  proc->osemaphore[position]=s;
+retget:
+  release(&stable.lock);
+  return retvalue;
+}
+
+// It releases the semaphore of the process if it is not in use, but only decreases the references in 1.
+// if the semaphore is not in the process, return -1.
+int
+semfree(int semid)
+{
+  struct semaphore* s;
+  int retvalue,pos;
+
+  acquire(&stable.lock);
+  pos=searchinprocess(semid);
+  if(pos==-1){
+    retvalue=-1;
+    goto retfree;
+  }
+  s=proc->osemaphore[pos];
+  if(s->references < 1){
+    retvalue=-2;
+    goto retfree;
+  }
+  s->references--;
+  proc->osemaphore[pos]=0;
+  retvalue=0;
+retfree:
+  release(&stable.lock);
+  return retvalue;
+}
+
+// Decreases the value of the semaphore if it is greater than 0 but sleeps the process.
+// if the semaphore is not in the process, return -1.
+int
+semdown(int semid)
+{
+  int value,pos;
+  struct semaphore* s;
+
+  acquire(&stable.lock);
+  pos=searchinprocess(semid);
+  if(pos==-1){
+    value=-1;
+    goto retdown;
+  }
+  s=proc->osemaphore[pos];
+  while(s->value<=0){
+    sleep(s,&stable.lock);
+  }
+  s->value--;
+  value=0;
+retdown:
+  release(&stable.lock);
+  return value;
+}
+
+// It increases the value of the semaphore and wake up processes waiting for it.
+// if the semaphore is not in the process, return -1.
+int
+semup(int semid)
+{
+  struct semaphore* s;
+  int pos;
+
+  acquire(&stable.lock);
+  pos=searchinprocess(semid);
+  if(pos==-1){
+    release(&stable.lock);
+    return -1;
+  }
+  s=proc->osemaphore[pos];
+  s->value++;
+  release(&stable.lock);
+  wakeup(s);
+  return 0;
+}
+
+// Decrease the semaphore references.
+void
+semclose(struct semaphore* s)
+{
+  acquire(&stable.lock);
+
+  if(s->references < 1)
+    panic("semclose");
+  s->references--;
+  release(&stable.lock);
+  return;
+
+}
+
+// Increase the semaphore references.
+struct semaphore*
+semdup(struct semaphore* s)
+{
+  acquire(&stable.lock);
+  if(s->references<0)
+    panic("semdup error");
+  s->references++;
+  release(&stable.lock);
+  return s;
+}
diff -rupN xv6-unrc/semaphore.h xv6-nuevo/semaphore.h
--- xv6-unrc/semaphore.h	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/semaphore.h	2018-05-07 16:11:53.426236523 -0300
@@ -0,0 +1,5 @@
+struct semaphore{
+  int id;  // semaphore identifier.
+  int references;  // number of references to the semaphore.
+  int value;  // semaphore value.
+};
diff -rupN xv6-unrc/syscall.c xv6-nuevo/syscall.c
--- xv6-unrc/syscall.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/syscall.c	2018-05-09 09:27:43.232543112 -0300
@@ -55,7 +55,7 @@ int
 argptr(int n, char **pp, int size)
 {
   int i;
-  
+
   if(argint(n, &i) < 0)
     return -1;
   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
@@ -98,6 +98,14 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_procstat(void);
+
+extern int sys_setpriority(void);
+
+extern int sys_semget(void);
+extern int sys_semfree(void);
+extern int sys_semdown(void);
+extern int sys_semup(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +129,12 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_procstat]   sys_procstat,
+[SYS_setpriority]   sys_setpriority,
+[SYS_semget]   sys_semget,
+[SYS_semfree]   sys_semfree,
+[SYS_semdown]   sys_semdown,
+[SYS_semup]   sys_semup
 };
 
 void
diff -rupN xv6-unrc/syscall.h xv6-nuevo/syscall.h
--- xv6-unrc/syscall.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/syscall.h	2018-05-03 17:10:22.602168349 -0300
@@ -20,3 +20,9 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_procstat  22
+#define SYS_setpriority  23
+#define SYS_semget  24
+#define SYS_semfree  25
+#define SYS_semdown  26
+#define SYS_semup  27
diff -rupN xv6-unrc/sysproc.c xv6-nuevo/sysproc.c
--- xv6-unrc/sysproc.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/sysproc.c	2018-05-09 15:15:25.710735074 -0300
@@ -61,7 +61,7 @@ sys_sleep(void)
 {
   int n;
   uint ticks0;
-  
+
   if(argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
@@ -83,9 +83,72 @@ int
 sys_uptime(void)
 {
   uint xticks;
-  
+
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
   return xticks;
 }
+
+// List the existing processes in the system and their status.
+int
+sys_procstat(void)
+{
+  cprintf("sys_procstat\n");
+  procdump();  // call function defined in proc.c
+  return 0;
+}
+
+// Set the priority to a process.
+int
+sys_setpriority(void)
+{
+  int level;
+  //cprintf("sys_setpriority\n");
+  if(argint(0, &level)<0)
+    return -1;
+  proc->priority=level;
+  return 0;
+}
+
+
+int
+sys_semget(void)
+{
+  int id, value;
+  if(argint(0, &id)<0)
+    return -1;
+  if(argint(1, &value)<0)
+    return -1;
+  return semget(id,value);
+}
+
+
+int
+sys_semfree(void)
+{
+  int id;
+  if(argint(0, &id)<0)
+    return -1;
+  return semfree(id);
+}
+
+
+int
+sys_semdown(void)
+{
+  int id;
+  if(argint(0, &id)<0)
+    return -1;
+  return semdown(id);
+}
+
+
+int
+sys_semup(void)
+{
+  int id;
+  if(argint(0, &id)<0)
+    return -1;
+  return semup(id);
+}
diff -rupN xv6-unrc/trap.c xv6-nuevo/trap.c
--- xv6-unrc/trap.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/trap.c	2018-05-23 19:46:38.359229263 -0300
@@ -22,7 +22,7 @@ tvinit(void)
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-  
+
   initlock(&tickslock, "time");
 }
 
@@ -77,9 +77,26 @@ trap(struct trapframe *tf)
             cpu->id, tf->cs, tf->eip);
     lapiceoi();
     break;
-   
+
   //PAGEBREAK: 13
   default:
+
+    if(proc && tf->trapno == T_PGFLT){
+      uint cr2=rcr2();
+      uint basepgaddr;
+
+
+      //  Verify if you wanted to access a correct address but not assigned.
+      //  if appropriate, assign one more page to the stack.
+      if(cr2 >= proc->sstack && cr2 < proc->sstack + MAXSTACKPAGES * PGSIZE){
+        cprintf("exhausted the stack, it will increase...virtual address:%x\n",cr2);
+        basepgaddr=PGROUNDDOWN(cr2);
+        if(allocuvm(proc->pgdir, basepgaddr, basepgaddr + PGSIZE) == 0)
+          panic("trap alloc stack");
+        break;
+      }
+    }
+
     if(proc == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
@@ -89,21 +106,31 @@ trap(struct trapframe *tf)
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
             rcr2());
     proc->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running 
+  // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+    if(proc->ticks++ == QUANTUM-1){  // Check if the amount of ticks of the current process reached the Quantum
+      //cprintf("El proceso con id %d tiene %d ticks\n",proc->pid, proc->ticks);
+      proc->ticks=0;  // Restarts the amount of process ticks
+      yield();
+    }
+
+  }
+  // check if the number of ticks was reached to increase the ages.
+  if((tf->trapno == T_IRQ0+IRQ_TIMER) && (ticks % TICKSFORAGE == 0))
+    calculateaging();
+
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
diff -rupN xv6-unrc/user/agingtest.c xv6-nuevo/user/agingtest.c
--- xv6-unrc/user/agingtest.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/user/agingtest.c	2018-04-19 16:20:39.741304769 -0300
@@ -0,0 +1,44 @@
+// Test that fork aging.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+
+
+
+void
+agingtest(void)
+{
+  int pid;
+  int i;
+
+  printf(1, "agingtest test\n");
+
+  for(i=0;i<4;i++){
+    pid=fork();
+
+    if(pid==0)
+      break;
+  }
+  if (pid==0){
+    for(;;){
+      setpriority(0);
+    }
+  }else{
+    setpriority(3);
+    for(;;){
+
+    }
+  }
+
+  printf(1, "aging test OK\n");
+}
+
+int
+main(void)
+{
+  agingtest();
+  exit();
+}
diff -rupN xv6-unrc/user/forktest.c xv6-nuevo/user/forktest.c
--- xv6-unrc/user/forktest.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/user/forktest.c	2018-04-05 12:07:11.592080666 -0300
@@ -21,30 +21,32 @@ forktest(void)
   printf(1, "fork test\n");
 
   for(n=0; n<N; n++){
+    if(n==5)
+      procstat();  // call procstat
     pid = fork();
     if(pid < 0)
       break;
     if(pid == 0)
       exit();
   }
-  
+
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
     exit();
   }
-  
+
   for(; n > 0; n--){
     if(wait() < 0){
       printf(1, "wait stopped early\n");
       exit();
     }
   }
-  
+
   if(wait() != -1){
     printf(1, "wait got too many\n");
     exit();
   }
-  
+
   printf(1, "fork test OK\n");
 }
 
diff -rupN xv6-unrc/user/pagestest.c xv6-nuevo/user/pagestest.c
--- xv6-unrc/user/pagestest.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/user/pagestest.c	2018-05-28 19:48:03.554837113 -0300
@@ -0,0 +1,27 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1024
+
+
+
+void
+pagestest(int n)
+{
+  int i;
+  int array[n];
+  for(i=0;i<n;i++){
+    array[i]=i;
+  }
+  //pagestest(n-1);
+  printf(1, "pages test OK %i\n",array[n]);
+}
+
+int
+main(void)
+{
+  pagestest(N);
+  exit();
+}
diff -rupN xv6-unrc/user/param.h xv6-nuevo/user/param.h
--- xv6-unrc/user/param.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/user/param.h	2018-05-23 19:39:02.810947254 -0300
@@ -10,4 +10,11 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-
+#define QUANTUM      5  // maximum number of ticks per process
+#define MLFLEVELS    4  // number of levels in the MLF structure
+#define TICKSFORAGE  10  // amount of ticks to increase the age of the process
+#define AGEFORAGINGS 5  // age that the processes must reach to update the priority.
+#define MLFMAXPRIORITY  0  // level with the highest priority in the MLF structure.
+#define MAXSEM 64  // maximum number of semaphores in the system.
+#define MAXPROCSEM 5  // maximum number of semaphores per process.
+#define MAXSTACKPAGES 8  // maximum number of stack pages per process.
diff -rupN xv6-unrc/user/prioritytest.c xv6-nuevo/user/prioritytest.c
--- xv6-unrc/user/prioritytest.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/user/prioritytest.c	2018-04-19 16:19:45.311291381 -0300
@@ -0,0 +1,47 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+
+
+
+void
+prioritytest(void)
+{
+  int i;
+  int pid;
+  printf(1, "prioritytest\n");
+    pid = fork();
+    for (i=0;i<4;i++){
+      fork();
+
+      if(pid==0){
+        break;
+      }
+    }
+
+    if(pid != 0){
+      for(;;){
+        setpriority(0);
+      }
+    }
+    if(pid == 0){
+        //setpriority(3);
+        for(;;){
+        }
+      }
+    }
+
+
+
+
+
+
+int
+main(void)
+{
+  prioritytest();
+  exit();
+}
diff -rupN xv6-unrc/user/semaphoretest.c xv6-nuevo/user/semaphoretest.c
--- xv6-unrc/user/semaphoretest.c	1969-12-31 21:00:00.000000000 -0300
+++ xv6-nuevo/user/semaphoretest.c	2018-05-28 16:21:54.938907000 -0300
@@ -0,0 +1,124 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+
+
+#define S  100 //size of buffer
+#define AMOUNTOFPRODUCERS 1
+#define AMOUNTOFCONSUMERS 1
+#define AMOUNTOFCYCLES 100  // amount of productions of the producers.
+
+
+int fd=0;
+int semfull;
+int semempty;
+int semb;
+
+void
+printf(int fd, char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+
+
+void
+enqueue()
+{
+  semdown(semb);
+  write(fd, "+1", sizeof("+1"));
+  semup(semb);
+}
+
+int
+unqueue()
+{
+  semdown(semb);
+  write(fd, "-1", sizeof("-1"));
+  semup(semb);
+  return 0;
+
+}
+
+void
+cons()
+{
+  for(;;) {
+    semdown(semempty);
+    unqueue();
+    semup(semfull);
+  }
+
+}
+
+void
+prod()
+{
+  int i;
+    for(i=0;i<AMOUNTOFCYCLES;i++) {
+      semdown(semfull);
+      enqueue();
+      semup(semempty);
+    }
+}
+
+void
+semtest(void)
+{
+
+  int i,j;
+  int pid=1;
+  fd=open("register", O_CREATE|O_RDWR);
+
+  for(i=0;i<AMOUNTOFPRODUCERS;i++){
+
+    pid=fork();
+
+    if(pid==0){
+      printf(1,"PRODUCTOR\n" );
+      break;
+    }
+
+  }
+  if(pid==0){
+    prod();
+  }
+
+  for(i=0;i<AMOUNTOFCONSUMERS;i++){
+    pid=fork();
+    if(pid==0){
+      printf(1,"CONSUMIDOR\n" );
+      break;
+    }
+
+  }
+  if(pid==0){
+    cons();
+  }
+  if(pid!=0){
+    for(j=0;j<AMOUNTOFPRODUCERS+AMOUNTOFPRODUCERS;j++){
+      wait();
+    }
+  }
+}
+
+int
+main(void)
+{
+  semempty=semget(-1,0);
+  printf(1,"despues de semget semempty\n" );
+
+  semfull=semget(-1,S);
+  printf(1,"despues de semget semfull\n" );
+
+  semb=semget(-1,1);
+  printf(1,"despues de semget semb\n" );
+
+  semtest();
+  exit();
+}
diff -rupN xv6-unrc/user/syscall.h xv6-nuevo/user/syscall.h
--- xv6-unrc/user/syscall.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/user/syscall.h	2018-05-03 17:10:22.602168349 -0300
@@ -20,3 +20,9 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_procstat  22
+#define SYS_setpriority  23
+#define SYS_semget  24
+#define SYS_semfree  25
+#define SYS_semdown  26
+#define SYS_semup  27
diff -rupN xv6-unrc/user/user.h xv6-nuevo/user/user.h
--- xv6-unrc/user/user.h	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/user/user.h	2018-05-03 16:50:21.660970003 -0300
@@ -23,6 +23,12 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int procstat(void);
+void setpriority(int priority);
+int semget(int semid, int initvalue);
+int semfree(int semid);
+int semdown(int semid);
+int semup(int semid);
 
 // ulib.c
 int stat(char*, struct stat*);
diff -rupN xv6-unrc/user/usys.S xv6-nuevo/user/usys.S
--- xv6-unrc/user/usys.S	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/user/usys.S	2018-05-03 17:07:22.553306376 -0300
@@ -29,3 +29,9 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(procstat)
+SYSCALL(setpriority)
+SYSCALL(semget)
+SYSCALL(semfree)
+SYSCALL(semdown)
+SYSCALL(semup)
diff -rupN xv6-unrc/vm.c xv6-nuevo/vm.c
--- xv6-unrc/vm.c	2015-04-08 15:02:06.000000000 -0300
+++ xv6-nuevo/vm.c	2018-05-23 13:34:42.281401240 -0300
@@ -33,7 +33,7 @@ seginit(void)
 
   lgdt(c->gdt, sizeof(c->gdt));
   loadgs(SEG_KCPU << 3);
-  
+
   // Initialize cpu-local storage.
   cpu = c;
   proc = 0;
@@ -57,7 +57,7 @@ walkpgdir(pde_t *pgdir, const void *va,
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
     // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table 
+    // be further restricted by the permissions in the page table
     // entries, if necessary.
     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
   }
@@ -72,7 +72,7 @@ mappages(pde_t *pgdir, void *va, uint si
 {
   char *a, *last;
   pte_t *pte;
-  
+
   a = (char*)PGROUNDDOWN((uint)va);
   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
   for(;;){
@@ -94,7 +94,7 @@ mappages(pde_t *pgdir, void *va, uint si
 // current process's page table during system calls and interrupts;
 // page protection bits prevent user code from using the kernel's
 // mappings.
-// 
+//
 // setupkvm() and exec() set up every page table like this:
 //
 //   0..KERNBASE: user memory (text+data+stack+heap), mapped to
@@ -102,7 +102,7 @@ mappages(pde_t *pgdir, void *va, uint si
 //   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
 //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
 //                for the kernel's instructions and r/o data
-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP, 
+//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
 //                                  rw data + free physical memory
 //   0xfe000000..0: mapped direct (devices such as ioapic)
 //
@@ -137,7 +137,7 @@ setupkvm(void)
   if (p2v(PHYSTOP) > (void*)DEVSPACE)
     panic("PHYSTOP too high");
   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
                 (uint)k->phys_start, k->perm) < 0)
       return 0;
   return pgdir;
@@ -182,7 +182,7 @@ void
 inituvm(pde_t *pgdir, char *init, uint sz)
 {
   char *mem;
-  
+
   if(sz >= PGSIZE)
     panic("inituvm: more than a page");
   mem = kalloc();
@@ -318,9 +318,11 @@ copyuvm(pde_t *pgdir, uint sz)
     return 0;
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+    //  continue;
       panic("copyuvm: pte should exist");
     if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
+      continue;
+      //panic("copyuvm: page not present");
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -383,4 +385,3 @@ copyout(pde_t *pgdir, uint va, void *p,
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
